// This is the main Prisma schema configuration for AttendFlow
// Contains datasource, generator, and all enums
// Individual models are defined in separate .prisma files
// Run 'npm run schema:merge' to combine all schema files before migrations or generation

generator client {
    provider = "prisma-client-js"
}

datasource db {
    provider = "postgresql"
}

// ==================== ENUMS ====================

// User roles enum
enum UserRole {
    ADMIN
    TEACHER
    STUDENT
}

// User account status enum
enum UserStatus {
    ACTIVE
    INACTIVE
    SUSPENDED
    PENDING
}

// Notification type enum
enum NotificationType {
    IN_APP
    EMAIL
    BOTH
}

// Email status enum
enum EmailStatus {
    PENDING
    SENT
    FAILED
}

// Attendance status enum
enum AttendanceStatus {
    PRESENT
    ABSENT
    LATE
    EXCUSED
}

// QR Code status enum
enum QRCodeStatus {
    ACTIVE
    EXPIRED
    USED
}

// Leave status enum
enum LeaveStatus {
    PENDING
    APPROVED
    REJECTED
}

// Leave type enum
enum LeaveType {
    SICK
    PERSONAL
    VACATION
    ACADEMIC
    EMERGENCY
}


// ==================== USER MODULE ====================
// Contains user-related models

// Main User model
model User {
    id           String     @id @default(cuid())
    email        String     @unique // REQUIRED: Email is mandatory for all users
    username     String?    @unique
    password     String
    name         String
    role         UserRole   @default(STUDENT)
    status       UserStatus @default(ACTIVE)
    avatar       String?
    phone        String?
    address      String?
    dateOfBirth  DateTime?
    departmentId String? // OPTIONAL: Can be assigned later
    createdAt    DateTime   @default(now())
    updatedAt    DateTime   @updatedAt

    // Student-specific relationships
    studentProfile Student?
    // Teacher-specific relationships
    teacherProfile Teacher?
    department     Department?     @relation("DepartmentUsers", fields: [departmentId], references: [id])
    classSchedules ClassSchedule[] @relation("TeacherSchedules")

    // Course relationships
    taughtCourses     Course[]           @relation("TeacherCourses")
    courseEnrollments CourseEnrollment[]

    // Attendance relationships
    attendanceRecords Attendance[]        @relation("UserAttendance")
    markedAttendances Attendance[]        @relation("AttendanceMarker")
    qrCheckIns        QRCheckIn[]         @relation("UserQRCheckIns")
    qrCodes           QRCode[]            @relation("UserQRCodes")
    teacherSessions   AttendanceSession[] @relation("TeacherSessions")

    // Leave relationships
    leaveRequests         LeaveRequest[] @relation("UserLeaveRequests")
    approvedLeaveRequests LeaveRequest[] @relation("ApprovedLeaveRequests")
    leaveBalance          LeaveBalance?  @relation("UserLeaveBalance")

    // Other relationships
    notifications           Notification[]
    refreshTokens           RefreshToken[]
    passwordResetTokens     PasswordResetToken[]
    emailVerificationTokens EmailVerificationToken[]

    @@map("users")
}

// Student profile model
model Student {
    id             String   @id @default(cuid())
    userId         String   @unique
    studentId      String   @unique // AUTO-GENERATED: Should not be in create forms
    batchId        String? // OPTIONAL: Can be assigned later via assignment API
    departmentId   String? // OPTIONAL: Can be assigned later via assignment API
    semester       Int      @default(1)
    enrollmentDate DateTime @default(now())
    gpa            Float?   @default(0.0)
    credits        Int      @default(0)
    isActive       Boolean  @default(true)
    createdAt      DateTime @default(now())
    updatedAt      DateTime @updatedAt

    // Relationships
    user              User           @relation(fields: [userId], references: [id], onDelete: Cascade)
    batch             Batch?         @relation(fields: [batchId], references: [id])
    department        Department?    @relation(fields: [departmentId], references: [id])
    attendanceRecords Attendance[]   @relation("StudentAttendance")
    leaveRequests     LeaveRequest[] @relation("StudentLeaveRequests")
    leaveBalance      LeaveBalance?  @relation("StudentLeaveBalance")

    @@map("students")
}

// Teacher profile model
model Teacher {
    id             String   @id @default(cuid())
    userId         String   @unique
    employeeId     String   @unique // AUTO-GENERATED: Should not be in create forms
    departmentId   String? // OPTIONAL: Can be assigned later via assignment API
    designation    String?
    specialization String?
    joinDate       DateTime @default(now())
    isActive       Boolean  @default(true)
    createdAt      DateTime @default(now())
    updatedAt      DateTime @updatedAt

    // Relationships
    user          User           @relation(fields: [userId], references: [id], onDelete: Cascade)
    department    Department?    @relation(fields: [departmentId], references: [id])
    courses       Course[]       @relation("TeacherProfileCourses")
    leaveRequests LeaveRequest[] @relation("TeacherLeaveRequests")
    leaveBalance  LeaveBalance?  @relation("TeacherLeaveBalance")
    headedDepartments Department[] @relation("DepartmentHead")

    @@map("teachers")
}


// ==================== ORGANIZATION MODULE ====================
// Contains models for organizational structure

// Batch model
model Batch {
    id          String   @id @default(cuid())
    name        String   @unique
    year        Int
    description String?
    startDate   DateTime
    endDate     DateTime
    isActive    Boolean  @default(true)
    createdAt   DateTime @default(now())
    updatedAt   DateTime @updatedAt

    // Relationships
    students  Student[]
    courses   Course[]
    schedules ClassSchedule[]

    @@map("batches")
}

// Department model
model Department {
    id          String   @id @default(cuid())
    name        String   @unique
    code        String   @unique
    description String?
    headId      String? // OPTIONAL: Department can exist without head, head can be assigned later
    isActive    Boolean  @default(true)
    createdAt   DateTime @default(now())
    updatedAt   DateTime @updatedAt

    // Relationships
    students  Student[]
    courses   Course[]
    teachers  Teacher[]
    users     User[]     @relation("DepartmentUsers")
    subjects  Subject[]
    semesters Semester[]
    head      Teacher?   @relation("DepartmentHead", fields: [headId], references: [id])

    @@map("departments")
}

// Semester model
model Semester {
    id           String   @id @default(cuid())
    name         String
    year         Int
    departmentId String
    startDate    DateTime
    endDate      DateTime
    isActive     Boolean  @default(true)
    createdAt    DateTime @default(now())
    updatedAt    DateTime @updatedAt

    // Relationships
    department Department @relation(fields: [departmentId], references: [id])
    courses    Course[]   @relation("CourseSemester")

    @@unique([departmentId, year, name])
    @@map("semesters")
}

// Subject model
model Subject {
    id           String   @id @default(cuid())
    name         String   @unique
    code         String   @unique
    description  String?
    credits      Int      @default(0)
    departmentId String
    isActive     Boolean  @default(true)
    createdAt    DateTime @default(now())
    updatedAt    DateTime @updatedAt

    // Relationships
    department Department @relation(fields: [departmentId], references: [id])
    courses    Course[]

    @@map("subjects")
}

// Course model
model Course {
    id           String   @id @default(cuid())
    title        String
    code         String   @unique
    description  String?
    credits      Int      @default(0)
    batchId      String? // OPTIONAL: Can be assigned later via assignment API
    departmentId String? // OPTIONAL: Can be assigned later via assignment API
    teacherId    String? // OPTIONAL: Can be assigned later via assignment API
    subjectId    String? // OPTIONAL: Can be assigned later
    semesterId   String? // OPTIONAL: Can be assigned later
    semester     Int      @default(1)
    isActive     Boolean  @default(true)
    createdAt    DateTime @default(now())
    updatedAt    DateTime @updatedAt

    // Relationships
    teacher            User?               @relation("TeacherCourses", fields: [teacherId], references: [id], map: "course_teacher_fkey")
    teacherProfile     Teacher?            @relation("TeacherProfileCourses", fields: [teacherId], references: [id], map: "course_teacher_profile_fkey")
    batch              Batch?              @relation(fields: [batchId], references: [id])
    department         Department?         @relation(fields: [departmentId], references: [id])
    subject            Subject?            @relation(fields: [subjectId], references: [id])
    semesterInfo       Semester?           @relation("CourseSemester", fields: [semesterId], references: [id])
    enrollments        CourseEnrollment[]
    attendanceRecords  Attendance[]        @relation("CourseAttendance")
    schedules          ClassSchedule[]
    qrcodes            QRCode[]            @relation("CourseQRCodes")
    attendanceSessions AttendanceSession[] @relation("CourseSessions")

    @@map("courses")
}

// Course enrollment model
model CourseEnrollment {
    id         String   @id @default(cuid())
    studentId  String
    courseId   String
    enrolledAt DateTime @default(now())

    // Relationships
    student User   @relation(fields: [studentId], references: [id])
    course  Course @relation(fields: [courseId], references: [id])

    @@unique([studentId, courseId])
    @@map("course_enrollments")
}

// Class schedule model
model ClassSchedule {
    id        String   @id @default(cuid())
    teacherId String? // OPTIONAL: Can be assigned later via assignment API
    courseId  String? // OPTIONAL: Can be assigned later via assignment API
    batchId   String? // OPTIONAL: Can be assigned later via assignment API
    dayOfWeek Int
    startTime String
    endTime   String
    room      String?
    semester  Int      @default(1)
    isActive  Boolean  @default(true)
    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt

    // Relationships
    teacher User?   @relation("TeacherSchedules", fields: [teacherId], references: [id])
    course  Course? @relation(fields: [courseId], references: [id])
    batch   Batch?  @relation(fields: [batchId], references: [id])

    @@map("class_schedules")
}

// Settings model
model Setting {
    id        String   @id @default(cuid())
    key       String   @unique
    value     String
    group     String   @default("GENERAL")
    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt

    @@map("settings")
}


// ==================== ATTENDANCE MODULE ====================
// Contains attendance-related models

// Attendance model
model Attendance {
    id                  String           @id @default(cuid())
    userId              String
    courseId            String
    date                DateTime
    status              AttendanceStatus
    checkIn             DateTime?
    checkOut            DateTime?
    notes               String?
    markedBy            String?
    createdAt           DateTime         @default(now())
    updatedAt           DateTime         @updatedAt
    qRCodeId            String?
    attendanceSessionId String?

    // Relationships
    user              User               @relation("UserAttendance", fields: [userId], references: [id], map: "attendance_user_fkey")
    course            Course             @relation("CourseAttendance", fields: [courseId], references: [id])
    marker            User?              @relation("AttendanceMarker", fields: [markedBy], references: [id])
    student           Student            @relation("StudentAttendance", fields: [userId], references: [id], map: "attendance_student_fkey")
    qrcode            QRCode?            @relation("QRCodeAttendance", fields: [qRCodeId], references: [id])
    attendanceSession AttendanceSession? @relation("SessionAttendances", fields: [attendanceSessionId], references: [id])

    @@unique([userId, courseId, date])
    @@map("attendances")
}

// QR Code model
model QRCode {
    id          String       @id @default(cuid())
    code        String       @unique
    courseId    String
    teacherId   String
    validFrom   DateTime
    validUntil  DateTime
    maxUses     Int          @default(1)
    usedCount   Int          @default(0)
    status      QRCodeStatus @default(ACTIVE)
    location    String?
    description String?
    createdAt   DateTime     @default(now())
    updatedAt   DateTime     @updatedAt

    // Relationships
    course      Course       @relation("CourseQRCodes", fields: [courseId], references: [id])
    teacher     User         @relation("UserQRCodes", fields: [teacherId], references: [id])
    attendances Attendance[] @relation("QRCodeAttendance")
    checkIns    QRCheckIn[]  @relation("QRCodeCheckIns")

    @@map("qr_codes")
}

// Attendance Session model
model AttendanceSession {
    id        String    @id @default(cuid())
    courseId  String
    teacherId String
    date      DateTime
    startTime DateTime
    endTime   DateTime?
    isActive  Boolean   @default(true)
    location  String?
    notes     String?
    createdAt DateTime  @default(now())
    updatedAt DateTime  @updatedAt

    // Relationships
    course      Course       @relation("CourseSessions", fields: [courseId], references: [id])
    teacher     User         @relation("TeacherSessions", fields: [teacherId], references: [id])
    attendances Attendance[] @relation("SessionAttendances")

    @@map("attendance_sessions")
}

// QR Check In model
model QRCheckIn {
    id          String   @id @default(cuid())
    qrCodeId    String
    userId      String
    checkInTime DateTime @default(now())
    location    String?
    ipAddress   String?
    userAgent   String?
    isValid     Boolean  @default(true)
    notes       String?
    createdAt   DateTime @default(now())

    // Relationships
    qrcode QRCode @relation("QRCodeCheckIns", fields: [qrCodeId], references: [id])
    user   User   @relation("UserQRCheckIns", fields: [userId], references: [id])

    @@map("qr_check_ins")
}


// ==================== LEAVE MODULE ====================
// Contains leave-related models

// Leave Request model
model LeaveRequest {
    id              String      @id @default(cuid())
    userId          String
    studentId       String?
    teacherId       String?
    startDate       DateTime
    endDate         DateTime
    reason          String
    type            LeaveType   @default(PERSONAL)
    status          LeaveStatus @default(PENDING)
    approvedBy      String?
    approvedAt      DateTime?
    rejectionReason String?
    documents       String?
    isPaid          Boolean     @default(false)
    createdAt       DateTime    @default(now())
    updatedAt       DateTime    @updatedAt

    // Relationships
    user     User     @relation("UserLeaveRequests", fields: [userId], references: [id])
    student  Student? @relation("StudentLeaveRequests", fields: [studentId], references: [id])
    teacher  Teacher? @relation("TeacherLeaveRequests", fields: [teacherId], references: [id])
    approver User?    @relation("ApprovedLeaveRequests", fields: [approvedBy], references: [id])

    @@map("leave_requests")
}

// Leave Balance model
model LeaveBalance {
    id            String   @id @default(cuid())
    userId        String   @unique
    studentId     String?  @unique
    teacherId     String?  @unique
    academicYear  String
    sickLeave     Int      @default(0)
    personalLeave Int      @default(0)
    vacationLeave Int      @default(0)
    usedSick      Int      @default(0)
    usedPersonal  Int      @default(0)
    usedVacation  Int      @default(0)
    createdAt     DateTime @default(now())
    updatedAt     DateTime @updatedAt

    // Relationships
    user    User     @relation("UserLeaveBalance", fields: [userId], references: [id])
    student Student? @relation("StudentLeaveBalance", fields: [studentId], references: [id])
    teacher Teacher? @relation("TeacherLeaveBalance", fields: [teacherId], references: [id])

    @@unique([userId, academicYear])
    @@map("leave_balances")
}

// Leave Policy model
model LeavePolicy {
    id                 String   @id @default(cuid())
    name               String   @unique
    description        String?
    academicYear       String
    maxSickLeave       Int      @default(5)
    maxPersonalLeave   Int      @default(3)
    maxVacationLeave   Int      @default(10)
    requireDocuments   Boolean  @default(false)
    minAdvanceDays     Int      @default(1)
    maxConsecutiveDays Int      @default(7)
    isActive           Boolean  @default(true)
    createdAt          DateTime @default(now())
    updatedAt          DateTime @updatedAt

    @@map("leave_policies")
}


// ==================== NOTIFICATION MODULE ====================
// Contains notification-related models

// Notification model
model Notification {
    id          String           @id @default(cuid())
    title       String
    message     String
    type        NotificationType @default(IN_APP)
    readStatus  Boolean          @default(false)
    emailStatus EmailStatus?
    recipientId String
    recipient   User             @relation(fields: [recipientId], references: [id], onDelete: Cascade)
    createdAt   DateTime         @default(now())
    updatedAt   DateTime         @updatedAt

    @@map("notifications")
}


// ==================== AUTH MODULE ====================
// Contains authentication-related models

// Refresh token model
model RefreshToken {
    id        String   @id @default(cuid())
    token     String   @unique
    userId    String
    expiresAt DateTime
    createdAt DateTime @default(now())

    user User @relation(fields: [userId], references: [id], onDelete: Cascade)

    @@map("refresh_tokens")
}

// Password reset token model
model PasswordResetToken {
    id        String   @id @default(cuid())
    token     String   @unique
    userId    String
    expiresAt DateTime
    createdAt DateTime @default(now())

    user User @relation(fields: [userId], references: [id], onDelete: Cascade)

    @@map("password_reset_tokens")
}

// Email verification token model
model EmailVerificationToken {
    id        String   @id @default(cuid())
    token     String   @unique
    userId    String
    expiresAt DateTime
    createdAt DateTime @default(now())

    user User @relation(fields: [userId], references: [id], onDelete: Cascade)

    @@map("email_verification_tokens")
}
